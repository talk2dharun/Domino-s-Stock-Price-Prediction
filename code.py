# -*- coding: utf-8 -*-
"""code.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UcaXNiB_7if-JiBnZso2XO3WLR2GVwku
"""

# Install required libraries
!pip install tensorflow scikit-learn matplotlib --quiet

# Importing necessary libraries
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Input
import matplotlib.pyplot as plt

# Prompt user to upload dataset
from google.colab import files
uploaded = files.upload()

# Load dataset
filename = list(uploaded.keys())[0]
data = pd.read_csv(filename)

# Convert 'Date' column to datetime and sort data
data['Date'] = pd.to_datetime(data['Date'])
data = data.sort_values('Date')

# Preprocessing: Selecting the 'Close' price and scaling
prices = data[['Close']]
scaler = MinMaxScaler(feature_range=(0, 1))
prices_scaled = scaler.fit_transform(prices)

# Create input-output pairs using a sliding window
def create_dataset(dataset, time_step=30):
    X, Y = [], []
    for i in range(len(dataset) - time_step):
        X.append(dataset[i:i + time_step, 0])
        Y.append(dataset[i + time_step, 0])
    return np.array(X), np.array(Y)

time_step = 30
X, Y = create_dataset(prices_scaled, time_step)
X = X.reshape(X.shape[0], X.shape[1], 1)

# Splitting data into training and testing sets
train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
Y_train, Y_test = Y[:train_size], Y[train_size:]

# Building the LSTM model
model = Sequential([
    Input(shape=(time_step, 1)),  # Use Input layer to avoid input_shape argument
    LSTM(50, return_sequences=True),
    LSTM(50, return_sequences=False),
    Dense(25),
    Dense(1)
])
model.compile(optimizer='adam', loss='mean_squared_error')

# Training the model
model.fit(X_train, Y_train, batch_size=32, epochs=20, verbose=1)

# Predicting on test data
Y_pred = model.predict(X_test, verbose=0)  # Ensure predictions don't trigger retracing
Y_pred_rescaled = scaler.inverse_transform(Y_pred.reshape(-1, 1))
Y_test_rescaled = scaler.inverse_transform(Y_test.reshape(-1, 1))

# Residual-based anomaly detection
residuals = np.abs(Y_test_rescaled - Y_pred_rescaled)
threshold = 3 * np.std(residuals)  # Set threshold as 3 standard deviations
anomalies = residuals > threshold

# Combined Plot: Stock Price Prediction with Anomaly Detection
plt.figure(figsize=(12, 6))
plt.plot(Y_test_rescaled, label='Actual Prices', color='blue', linewidth=1.5)
plt.plot(Y_pred_rescaled, label='Predicted Prices', color='orange', linewidth=1.5)
plt.scatter(np.where(anomalies)[0], Y_test_rescaled[anomalies], color='red', label='Anomalies', s=50, zorder=5)
plt.title('Stock Price Prediction with Anomaly Detection')
plt.xlabel('Time')
plt.ylabel('Stock Price')
plt.legend()
plt.show()

# Analyzing and generating dynamic paragraph
anomaly_indices = np.where(anomalies)[0]
anomaly_values = Y_test_rescaled[anomalies]
mean_actual = np.mean(Y_test_rescaled)
mean_predicted = np.mean(Y_pred_rescaled)
actual_range = (np.min(Y_test_rescaled), np.max(Y_test_rescaled))
predicted_range = (np.min(Y_pred_rescaled), np.max(Y_pred_rescaled))
num_anomalies = len(anomaly_indices)
total_data_points = len(Y_test_rescaled)
anomaly_percentage = (num_anomalies / total_data_points) * 100

# Generating the paragraph dynamically
paragraph = f"""
The plot shows actual (blue) and predicted (orange) stock prices for the testing period.

Actual prices range from ₹{actual_range[0]:.2f} to ₹{actual_range[1]:.2f}, with predicted prices closely following this range, but some deviations.

Anomalies, marked by red dots, occur when the difference between actual and predicted prices exceeds ₹{threshold:.2f} (three standard deviations).

Notable anomalies were observed at time indices {', '.join(map(str, anomaly_indices))}, suggesting unexpected market movements or model limitations.

The model generally aligns well with actual values, with anomalies accounting for {anomaly_percentage:.2f}% of the data points.
"""

# Display the dynamically generated paragraph
from IPython.display import display, Markdown
display(Markdown(paragraph))